#include <x86intrin.h>
#include <cstdint>
#include <iostream>
#include <fstream>
#include <set>
#include <mutex>
#include <vector>
#include <dlfcn.h>
#include <pthread.h>
#include "funtrace.h"

#ifndef FUNTRACE_BUF_SIZE
//must be a power of 2
#define FUNTRACE_BUF_SIZE (1024*16)
#endif

//we could ask the user to compile this file without -finstrument-functions
//instead of peppering all of the code with NOINSTR. but this file wants
//to be compiled into the executable (rather than be its own shared object
//with its own build script - which would make TLS access slower), and we
//don't want the user to have to figure out how to compile all of their program
//with -finstrument-functions but not use this compiler flag with this one file
//which compiles together with the other files in that program - could be hard
//
//note that we do things like add explicit ctors/dtors to non-POD structs
//which would have these generated by the compiler - because this way we can
//put NOINSTR on them...
#define NOINSTR __attribute__((no_instrument_function))

struct trace_entry
{
    void* func;
    uint64_t cycle;
};

struct trace_data
{
    int pos;
    bool pause;
    unsigned char pad[16-sizeof(int)-sizeof(bool)];
    trace_entry buf[FUNTRACE_BUF_SIZE/sizeof(trace_entry)];
};

struct trace_global_state
{
    std::set<trace_data*> thread_traces;
    std::ofstream trace_file;
    std::mutex mutex; //guards both thread_traces (from newly created
    //and destroyed threads adding/removing their trace buffers to the set)
    //and trace_file (from calls to funtrace_pause_and_write_current_snapshot()
    //which might come from multiple threads)

    NOINSTR trace_global_state() {}
    NOINSTR ~trace_global_state() {}

    std::ostream& NOINSTR file()
    {
        if(!trace_file.is_open()) {
            trace_file.open("funtrace.raw", std::ios::binary);
        }
        return trace_file;
    }
};

//this alignment as well as the padding is for the SSE 128b streaming
//instructions; however they aren't actually used since they didn't seem
//to help in benchmarking...
thread_local trace_data g_thread_trace __attribute__((aligned(16))) ;
trace_global_state g_trace_state;

static inline void NOINSTR trace(void* ptr, uint64_t is_ret)
{
    uint64_t cycle = __rdtsc();
    static_assert(sizeof(trace_entry) == 16);
    if(g_thread_trace.pause) {
        return;
    }
    int pos = g_thread_trace.pos;
    trace_entry* entry = (trace_entry*)((uint64_t)&g_thread_trace.buf + pos);
    //this generates prefetchw and doesn't impact povray's runtime (with any of +4, 8, 12, 16)
    //__builtin_prefetch(entry+4, 1, 0);
    pos = (pos+16) & (sizeof(g_thread_trace.buf)-1);

    uint64_t func = ((uint64_t)ptr) | (is_ret << 63);
    //straightforward writing:
    entry->func = (void*)func;
    entry->cycle = cycle;

    //this generates movntq and makes povray slower relatively to straightforward writing
    //__m64* pm64 = (__m64*)entry;
    //_mm_stream_pi(pm64, _m_from_int64(func));
    //_mm_stream_pi(pm64+1, _m_from_int64(cycle));

    //this generates vmovntdq and also makes povray slower
    //__m128i xmm = _mm_set_epi64x(cycle, func);
    //_mm_stream_si128((__m128i*)entry, xmm);

    g_thread_trace.pos = pos;
}

extern "C" void NOINSTR __cyg_profile_func_enter(void* func, void* caller) { trace(func, 0); }
extern "C" void NOINSTR __cyg_profile_func_exit(void* func, void* caller) { trace(func, 1); }

struct funtrace_procmaps
{
    std::vector<char> data;
    NOINSTR funtrace_procmaps() {}
    NOINSTR ~funtrace_procmaps() {}
};

const int MAGIC_LEN = 8;

static void NOINSTR write_procmaps(funtrace_procmaps* procmaps)
{
    std::ostream& file = g_trace_state.file();
    file.write("PROCMAPS", MAGIC_LEN);
    uint64_t size = procmaps->data.size();
    file.write((char*)&size, sizeof size);
    file.write(&procmaps->data[0], size);
}

static void NOINSTR write_tracebufs(const std::set<trace_data*>& thread_traces)
{
    std::ostream& file = g_trace_state.file();
    char zero[sizeof(uint64_t)] = {0};
    file.write("FUNTRACE", MAGIC_LEN);
    file.write(zero, sizeof zero);
    for(auto trace : thread_traces) {
        file.write("TRACEBUF", MAGIC_LEN);
        uint64_t size = sizeof(trace->buf);
        file.write((char*)&size, sizeof size);
        file.write((char*)&trace->buf, size);
    }
    file.write("ENDTRACE", MAGIC_LEN);
    file.write(zero, sizeof zero);
}

extern "C" void NOINSTR funtrace_pause_and_write_current_snapshot()
{
    std::lock_guard<std::mutex> guard(g_trace_state.mutex);
    for(auto trace : g_trace_state.thread_traces) {
        trace->pause = true;
    }
    funtrace_procmaps* procmaps = funtrace_save_procmaps();
    write_procmaps(procmaps);
    funtrace_free_procmaps(procmaps);

    //we don't allocate a snapshot - we save the memory for this by writing
    //straight from the trace buffers (at the expense of pausing tracing
    //for more time)
    //
    //(we didn't mind briefly allocating procmaps because it's very little data)
    write_tracebufs(g_trace_state.thread_traces);

    for(auto trace : g_trace_state.thread_traces) {
        trace->pause = false;
    }
}

extern "C" funtrace_procmaps* NOINSTR funtrace_save_procmaps()
{
    std::ifstream maps_file("/proc/self/maps", std::ios::binary);
    if (!maps_file.is_open()) {
        std::cerr << "funtrace - failed to open /proc/self/maps, traces will be impossible to decode" << std::endl;
        return nullptr;
    }

    funtrace_procmaps* p = new funtrace_procmaps;

    p->data = std::vector<char>(
        (std::istreambuf_iterator<char>(maps_file)),
        std::istreambuf_iterator<char>());

    return p;
}

struct funtrace_snapshot
{
    std::set<trace_data*> thread_traces;
    NOINSTR funtrace_snapshot() {}
    NOINSTR ~funtrace_snapshot() {}
};

funtrace_snapshot* NOINSTR funtrace_pause_and_save_snapshot()
{
    std::lock_guard<std::mutex> guard(g_trace_state.mutex);
    for(auto trace : g_trace_state.thread_traces) {
        trace->pause = true;
    }
    funtrace_snapshot* snapshot = new funtrace_snapshot;
    for(auto trace : g_trace_state.thread_traces) {
        trace_data* copy = new trace_data(*trace);
        snapshot->thread_traces.insert(copy);
    }
    for(auto trace : g_trace_state.thread_traces) {
        trace->pause = false;
    }
    return snapshot;
}

void NOINSTR funtrace_free_procmaps(funtrace_procmaps* procmaps)
{
    delete procmaps;
}

void NOINSTR funtrace_free_snapshot(funtrace_snapshot* snapshot)
{
    for(auto trace : snapshot->thread_traces) {
        delete trace;
    }
    delete snapshot;
}

void NOINSTR funtrace_write_saved_snapshot(const char* filename, funtrace_procmaps* procmaps, funtrace_snapshot* snapshot)
{
    std::ofstream file(filename);
    write_procmaps(procmaps);
    write_tracebufs(snapshot->thread_traces);
}

// we interpose pthread_create in order to implement the thing that having
// a ctor & dtor for the trace_data struct would do, but more efficiently.
//
// we need a thread's thread_local trace_data to be added to g_trace_state.thread_traces
// set when a new thread is created, and we need it to be removed from this set
// when it is destroyed. a ctor & dtor would do it but the ctor slows down the trace()
// function which would need to check every time if the thread_local object was
// already constructed or not, and call the ctor if it isn't.
//
// interposing pthread_create lets us avoid this check in the trace() function.
//
// a more portable and/or succinct yet still efficient approach would be great!

typedef int (*original_pthread_create_type)(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *);

struct pthread_args
{
    void* (*func)(void*);
    void* arg;
};

void* NOINSTR pthread_entry_point(void* arg)
{
    {
        std::lock_guard<std::mutex> guard(g_trace_state.mutex);
        g_trace_state.thread_traces.insert(&g_thread_trace);
    }
    pthread_args* args = (pthread_args*)arg;
    void* ret = args->func(args->arg);
    delete args;
    {
        std::lock_guard<std::mutex> guard(g_trace_state.mutex);
        g_trace_state.thread_traces.erase(&g_thread_trace);
    }
    return ret;
}

int NOINSTR pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                   void *(*start_routine)(void *), void *arg) {
    // Find the original pthread_create using dlvsym; using dlsym might give us
    // an older version without support for the attr argument... spoken from experience!
    static original_pthread_create_type original_pthread_create = NULL;
    if (!original_pthread_create) {
        original_pthread_create = (original_pthread_create_type)dlvsym(RTLD_NEXT, "pthread_create", "GLIBC_2.2.5");
        if (!original_pthread_create) {
            fprintf(stderr, "Error locating original pthread_create: %s\n", dlerror());
            exit(EXIT_FAILURE);
        }
    }

    pthread_args* args = new pthread_args;
    args->func = start_routine;
    args->arg = arg;
    // Call the original pthread_create
    return original_pthread_create(thread, attr, pthread_entry_point, args);
}

//...and we need to register the main thread's trace separately, this time using a ctor
//(it's not global ctors that are the problem, it's the thread_locals' ctors); we don't
//need a dtor - the main thread never "goes out of scope" until the program terminates
struct register_main_thread
{
    NOINSTR register_main_thread()
    {
        std::lock_guard<std::mutex> guard(g_trace_state.mutex);
        g_trace_state.thread_traces.insert(&g_thread_trace);
    }
}
g_register_main_thread;
