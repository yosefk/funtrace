#include <x86intrin.h>
#include <cstdint>
#include <iostream>
#include <fstream>
#include <set>
#include <mutex>
#include <vector>
#include <dlfcn.h>
#include <pthread.h>
#include "funtrace.h"
#include "funtrace_buf_size.h"

//we could ask the user to compile this file without -finstrument-functions/-pg
//instead of peppering all of the code with NOINSTR. but this file wants
//to be compiled into the executable (rather than be its own shared object
//with its own build script - which would make TLS access slower), and we
//don't want the user to have to figure out how to compile all of their program
//with -finstrument-functions/-pg but not use these compiler flags with this one file
//which compiles together with the other files in that program - could be hard
//in some build systems.
//
//note that we do things like add explicit ctors/dtors to non-POD structs
//which would have these generated by the compiler - because this way we can
//put NOINSTR on them...
#define NOINSTR __attribute__((no_instrument_function))

//if you modify this, update funtrace_pg.S as well
struct trace_entry
{
    void* func;
    uint64_t cycle;
};

struct trace_data
{
    trace_entry* pos; //pos points into buf which must be aligned to FUNTRACE_BUF_SIZE
    bool enabled;
    trace_entry* buf;

    inline void NOINSTR pause_tracing() { enabled = false; }
    inline void NOINSTR resume_tracing() { enabled = true; }

    void NOINSTR allocate()
    {
        trace_entry* entries = nullptr;
        //we align the allocation to twice the buffer size so that after we increment the pos pointer,
        //we can clear the bit FUNTRACE_LOG_BUF_SIZE without worrying that the increment
        //carried values to bits at higher positions
        int memret = posix_memalign((void**)&entries, FUNTRACE_BUF_SIZE*2, FUNTRACE_BUF_SIZE);
        (void)memret;
        buf = entries;
        pos = entries;
        enabled = true;
    }

    void NOINSTR free()
    {
        ::free(buf);
        enabled = false;
        buf = nullptr;
        pos = nullptr;
    }

    inline void NOINSTR trace(void* ptr, uint64_t is_ret);
};

inline void NOINSTR trace_data::trace(void* ptr, uint64_t is_ret)
{
    static_assert(sizeof(trace_entry) == 16);

    bool paused = !enabled;
    trace_entry* entry = pos;

    uint64_t cycle = __rdtsc();
    uint64_t func = ((uint64_t)ptr) | (is_ret << FUNTRACE_RETURN_BIT);

    if(paused) {
        return;
    }
    //this generates prefetchw and doesn't impact povray's runtime (with any of +4, 8, 12, 16)
    //__builtin_prefetch(entry+4, 1, 0);

    //straightforward writing:
    entry->func = (void*)func;
    entry->cycle = cycle;

    //this generates movntq and makes povray slower relatively to straightforward writing
    //__m64* pm64 = (__m64*)entry;
    //_mm_stream_pi(pm64, _m_from_int64(func));
    //_mm_stream_pi(pm64+1, _m_from_int64(cycle));

    //this generates vmovntdq and also makes povray slower
    //__m128i xmm = _mm_set_epi64x(cycle, func);
    //_mm_stream_si128((__m128i*)entry, xmm);

    entry = (trace_entry*)(uint64_t(entry + 1) & ~(1 << FUNTRACE_LOG_BUF_SIZE));
    //printf("%p 0x%x\n", (void*)entry, uint64_t(entry) & (FUNTRACE_BUF_SIZE*2-1));

    pos = entry;
}

thread_local trace_data g_thread_trace;

extern "C" void NOINSTR __cyg_profile_func_enter(void* func, void* caller) { g_thread_trace.trace(func, 0); }
extern "C" void NOINSTR __cyg_profile_func_exit(void* func, void* caller) { g_thread_trace.trace(func, 1); }

//funtrace_pg.S is based on assembly generated from these C functions, massaged
//to avoid clobbering the registers where arguments might have been passed to
//the caller of __fentry__ and __return__ (and in __return__'s case,
//also to avoid clobbering the caller's return value) - unfortunately didn't
//find a way to tell gcc not to do that given C code, other than that there's
//not really any need to use assembly rather than C here
//
//(the other changes to funtrace_pg.S in addition to register renaming are
//to put macros like FUNTRACE_LOG_BUF_SIZE instead of the constants generated by gcc)
#if 0
extern "C" void NOINSTR __fentry__() {
    g_thread_trace.trace(__builtin_return_address(0),0);
}
extern "C" void NOINSTR __return__() { 
    g_thread_trace.trace(__builtin_return_address(0),1); 
}
#endif

struct trace_global_state
{
    //a set is easier to erase from but slower to iterate over and we want
    //to iterate quickly when pausing the tracing
    std::vector<trace_data*> thread_traces;
    std::ofstream trace_file;
    std::mutex mutex; //guards both thread_traces (from newly created
    //and destroyed threads adding/removing their trace buffers to the set)
    //and trace_file (from calls to funtrace_pause_and_write_current_snapshot()
    //which might come from multiple threads)

    NOINSTR trace_global_state() {}
    NOINSTR ~trace_global_state() {}

    std::ostream& NOINSTR file()
    {
        if(!trace_file.is_open()) {
            trace_file.open("funtrace.raw", std::ios::binary);
        }
        return trace_file;
    }

    //should be called once - can't be called again before unregister_this_thread()
    void NOINSTR register_this_thread()
    {
        std::lock_guard<std::mutex> guard(mutex);
        thread_traces.push_back(&g_thread_trace);
    }

    //safe to call many times without calling register_this_thread() between the calls
    void NOINSTR unregister_this_thread()
    {
        std::lock_guard<std::mutex> guard(mutex);
        for(int i=0; i<(int)thread_traces.size(); ++i) {
            if(thread_traces[i] == &g_thread_trace) {
                thread_traces[i] = thread_traces.back();
                thread_traces.pop_back();
                break;
            }
        }
    }
};

trace_global_state g_trace_state;

struct funtrace_procmaps
{
    std::vector<char> data;
    NOINSTR funtrace_procmaps() {}
    NOINSTR ~funtrace_procmaps() {}
};

const int MAGIC_LEN = 8;

static void NOINSTR write_procmaps(std::ostream& file, funtrace_procmaps* procmaps)
{
    file.write("PROCMAPS", MAGIC_LEN);
    uint64_t size = procmaps->data.size();
    file.write((char*)&size, sizeof size);
    file.write(&procmaps->data[0], size);
}

static void NOINSTR write_tracebufs(std::ostream& file, const std::vector<trace_data*>& thread_traces)
{
    char zero[sizeof(uint64_t)] = {0};
    file.write("FUNTRACE", MAGIC_LEN);
    file.write(zero, sizeof zero);
    for(auto trace : thread_traces) {
        file.write("TRACEBUF", MAGIC_LEN);
        uint64_t size = FUNTRACE_BUF_SIZE;
        file.write((char*)&size, sizeof size);
        file.write((char*)trace->buf, size);
    }
    file.write("ENDTRACE", MAGIC_LEN);
    file.write(zero, sizeof zero);
}

extern "C" void NOINSTR funtrace_pause_and_write_current_snapshot()
{
    std::lock_guard<std::mutex> guard(g_trace_state.mutex);

    for(auto trace : g_trace_state.thread_traces) {
        trace->pause_tracing();
    }
    std::ostream& file = g_trace_state.file();
    funtrace_procmaps* procmaps = funtrace_get_procmaps();
    write_procmaps(file, procmaps);
    funtrace_free_procmaps(procmaps);

    //we don't allocate a snapshot - we save the memory for this by writing
    //straight from the trace buffers (at the expense of pausing tracing
    //for more time)
    //
    //(we didn't mind briefly allocating procmaps because it's very little data)
    write_tracebufs(file, g_trace_state.thread_traces);

    for(auto trace : g_trace_state.thread_traces) {
        trace->resume_tracing();
    }

    file.flush();
}

extern "C" funtrace_procmaps* NOINSTR funtrace_get_procmaps()
{
    std::ifstream maps_file("/proc/self/maps", std::ios::binary);
    if (!maps_file.is_open()) {
        std::cerr << "funtrace - failed to open /proc/self/maps, traces will be impossible to decode" << std::endl;
        return nullptr;
    }

    funtrace_procmaps* p = new funtrace_procmaps;

    p->data = std::vector<char>(
        (std::istreambuf_iterator<char>(maps_file)),
        std::istreambuf_iterator<char>());

    return p;
}

struct funtrace_snapshot
{
    std::vector<trace_data*> thread_traces;
    NOINSTR funtrace_snapshot() {}
    NOINSTR ~funtrace_snapshot() {}
};

funtrace_snapshot* NOINSTR funtrace_pause_and_get_snapshot()
{
    std::lock_guard<std::mutex> guard(g_trace_state.mutex);
    for(auto trace : g_trace_state.thread_traces) {
        trace->pause_tracing();
    }
    funtrace_snapshot* snapshot = new funtrace_snapshot;
    for(auto trace : g_trace_state.thread_traces) {
        trace_data* copy = new trace_data(*trace);
        snapshot->thread_traces.push_back(copy);
    }
    for(auto trace : g_trace_state.thread_traces) {
        trace->resume_tracing();
    }
    return snapshot;
}

void NOINSTR funtrace_free_procmaps(funtrace_procmaps* procmaps)
{
    delete procmaps;
}

void NOINSTR funtrace_free_snapshot(funtrace_snapshot* snapshot)
{
    for(auto trace : snapshot->thread_traces) {
        delete trace;
    }
    delete snapshot;
}

void NOINSTR funtrace_write_saved_snapshot(const char* filename, funtrace_procmaps* procmaps, funtrace_snapshot* snapshot)
{
    std::ofstream file(filename);
    write_procmaps(file, procmaps);
    write_tracebufs(file, snapshot->thread_traces);
}

// we interpose pthread_create in order to implement the thing that having
// a ctor & dtor for the trace_data struct would do, but more efficiently.
//
// we need a thread's thread_local trace_data to be added to g_trace_state.thread_traces
// set when a new thread is created, and we need it to be removed from this set
// when it is destroyed. a ctor & dtor would do it but the ctor slows down the trace()
// function which would need to check every time if the thread_local object was
// already constructed or not, and call the ctor if it isn't.
//
// interposing pthread_create lets us avoid this check in the trace() function.
//
// a more portable and/or succinct yet still efficient approach would be great!

typedef int (*original_pthread_create_type)(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *);

struct pthread_args
{
    void* (*func)(void*);
    void* arg;
};

void* NOINSTR pthread_entry_point(void* arg)
{
    g_thread_trace.allocate();
    g_trace_state.register_this_thread();

    pthread_args* args = (pthread_args*)arg;
    void* ret = args->func(args->arg);
    delete args;

    g_trace_state.unregister_this_thread();
    g_thread_trace.free();
    return ret;
}

int NOINSTR pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                   void *(*start_routine)(void *), void *arg) {
    // Find the original pthread_create using dlvsym; using dlsym might give us
    // an older version without support for the attr argument... spoken from experience!
    static original_pthread_create_type original_pthread_create = NULL;
    if (!original_pthread_create) {
        original_pthread_create = (original_pthread_create_type)dlvsym(RTLD_NEXT, "pthread_create", "GLIBC_2.2.5");
        if (!original_pthread_create) {
            fprintf(stderr, "Error locating original pthread_create: %s\n", dlerror());
            exit(EXIT_FAILURE);
        }
    }

    pthread_args* args = new pthread_args;
    args->func = start_routine;
    args->arg = arg;
    // Call the original pthread_create
    return original_pthread_create(thread, attr, pthread_entry_point, args);
}

//...and we need to register the main thread's trace separately, this time using a ctor
//(it's not global ctors that are the problem, it's the thread_locals' ctors); we don't
//need a dtor - the main thread never "goes out of scope" until the program terminates
struct register_main_thread
{
    NOINSTR register_main_thread()
    {
        g_thread_trace.allocate();
        g_trace_state.register_this_thread();
    }

    NOINSTR ~register_main_thread()
    {
        g_trace_state.unregister_this_thread();
        g_thread_trace.free();
    }
}
g_funtrace_register_main_thread;

//we register a signal handler for SIGTRAP, and have a thread waiting for the signal
//to arrive and dumping trace data when it does. this is good for programs you don't
//want to modify beyond rebuilding (otherwise it's not so great since you can't time
//the event very well, but it might still be enough to get a feeling of what the program
//is doing)
#ifndef FUNTRACE_NO_SIGTRAP

#include <thread>
#include <atomic>
#include <csignal>

struct sigtrap_handler
{
    std::mutex mutex;
    std::thread thread;
    std::atomic<bool> quit;
    std::atomic<bool> done;

    static void NOINSTR signal_handler(int);
    void NOINSTR thread_func();
    NOINSTR sigtrap_handler()
    {
        mutex.lock();
        quit = false;
        done = false;
        thread = std::thread([this] {
            thread_func();
        });
        signal(SIGTRAP, signal_handler);
    }
    NOINSTR ~sigtrap_handler()
    {
        quit = true;
        while(!done) {
            mutex.unlock();
        }
        thread.join();
    }
}
g_funtrace_sigtrap_handler;

void NOINSTR sigtrap_handler::signal_handler(int)
{
    g_funtrace_sigtrap_handler.mutex.unlock();
}

void NOINSTR sigtrap_handler::thread_func()
{
    //we don't want to trace the SIGTRAP-handling thread
    g_trace_state.unregister_this_thread();
    while(true) {
        mutex.lock();
        if(quit) {
            done = true;
            break;
        }
        funtrace_pause_and_write_current_snapshot();
    }
}

#endif //FUNTRACE_NO_SIGTRAP
